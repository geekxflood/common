# AI Development Guidelines for Geekxflood Common

This file provides comprehensive guidelines for AI assistants working on the Geekxflood Common project. These guidelines ensure consistency, quality, and adherence to project standards.

## Project Overview

The Geekxflood Common project is a collection of Go packages providing foundational functionality:

- **config**: Configuration management with CUE schema validation and hot reload
- **logging**: Structured logging with component isolation and context integration
- **ruler**: CUE expression evaluation with intelligent rule selection

## Core Principles

### Code Quality First

- All code must pass quality gates: `go fmt`, `golangci-lint`, `go test`, `go test -race`, `gosec`, `deadcode`
- Maintain 80%+ test coverage with comprehensive unit and integration tests
- Follow Go best practices and project-specific coding standards
- Use semantic versioning and clear commit messages

### Documentation Excellence

- Every package must have standardized documentation following the established template
- All code examples must be complete, tested, and working
- Use consistent formatting: checkmarks (✅) for features, proper code blocks with language tags
- Keep documentation current with code changes

### Simplicity and Clarity

- Prefer simple, focused solutions over complex ones
- Use clear, descriptive names for packages, types, and functions
- Avoid "production-grade" or marketing language in documentation
- Write code that is easy to understand and maintain

## Development Standards

### Package Structure

```text
package/
├── package.go              # Main types and interfaces
├── package_test.go         # Unit tests
├── package.md              # Package documentation
└── testdata/              # Test data files
```

### Naming Conventions

- **Packages**: lowercase, single words (`config`, `logging`, `ruler`)
- **Types**: PascalCase (`Manager`, `ComponentLogger`)
- **Functions**: PascalCase for exported, camelCase for unexported
- **Variables**: camelCase, descriptive names

### Error Handling

- Always handle errors explicitly, never ignore them
- Create package-specific error types for different categories
- Wrap errors with context using `fmt.Errorf` with `%w` verb
- Provide actionable error messages

### Testing Requirements

- Use table-driven tests for multiple test cases
- Include both success and failure test cases
- Create helper functions for common test setup
- Use `t.Helper()` in test helper functions
- Clean up resources with `t.Cleanup()`

## Code Implementation Guidelines

### Interface Design

- Define interfaces in consuming packages, not providing packages
- Keep interfaces small and focused
- Use composition to build larger interfaces from smaller ones
- Return interfaces when possible to allow different implementations

### Concurrency

- Design for thread safety from the start
- Use context for cancellation and timeouts
- Protect shared state with appropriate synchronization
- Avoid goroutine leaks by ensuring proper cleanup

### Performance

- Minimize allocations in hot paths
- Use object pooling for frequently allocated objects
- Include benchmarks for performance-critical code
- Profile and optimize based on actual usage patterns

## Documentation Standards

### Package Documentation Template

```markdown
# Package `name`

Brief description (1-2 sentences, no marketing language).

## Key Features

✅ **Feature Name** - Brief description
✅ **Another Feature** - Brief description

## Installation

```bash
go get github.com/geekxflood/common/packagename
```

## Quick Start

### Code Examples

- Always include complete, runnable examples
- Use proper syntax highlighting with language tags
- Test all examples to ensure they work
- Show practical, real-world usage scenarios

## Quality Assurance

### Pre-Commit Checklist

Before any code changes:

- [ ] Code is formatted (`go fmt ./...`)
- [ ] Linting passes (`golangci-lint run --config .golangci.yml`)
- [ ] All tests pass (`go test ./...`)
- [ ] No race conditions (`go test -race ./...`)
- [ ] Security scan passes (`gosec -conf .gosec.json ./...`)
- [ ] No dead code (`deadcode -test ./...`)
- [ ] Documentation updated
- [ ] Commit message follows conventional format

### Code Review Requirements

- Clear description explaining what and why
- Tests added for new functionality
- Documentation updated appropriately
- All CI checks passing
- Small, focused changes (< 400 lines)

## Specific Package Guidelines

### Config Package

- Support both file-based and inline schema content
- Implement granular hot reload (schema and config independently)
- Handle environment variable substitution with defaults
- Provide type-safe configuration access methods
- Use CUE for schema validation and type checking

### Logging Package

- Build on Go's standard `log/slog` package
- Support component-aware logging with automatic context
- Provide both global and component-specific loggers
- Support multiple output formats (logfmt, json)
- Integrate seamlessly with Go's context package

### Ruler Package

- Use CUE expressions for rule evaluation
- Support structured input/output specifications
- Implement smart rule selection based on available data
- Optimize for high-performance scenarios (~8μs evaluation)
- Provide thread-safe concurrent evaluation

## Common Patterns

### Constructor Functions

```go
// Return interfaces when possible
func NewManager(opts Options) (Manager, error) {
    return &manager{...}, nil
}
```

### Error Types

```go
type ConfigError struct {
    Key     string
    Message string
    Cause   error
}

func (e ConfigError) Error() string {
    return fmt.Sprintf("config error for key %q: %s", e.Key, e.Message)
}

func (e ConfigError) Unwrap() error {
    return e.Cause
}
```

### Test Structure

```go
func TestFunction(t *testing.T) {
    tests := []struct {
        name     string
        input    string
        expected string
        wantErr  bool
    }{
        // Test cases...
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Test implementation
        })
    }
}
```

## Tools and Configuration

### Required Tools

- **golangci-lint**: Use project's `.golangci.yml` configuration (never modify)
- **gosec**: Security scanning with project's `.gosec.json` configuration
- **deadcode**: Dead code detection
- **go test**: Built-in testing with race detection

### CI/CD Integration

All quality checks are automated in the CI/CD pipeline and must pass before merging.

## Workflow Standards

### Branch Naming

- `feature/package-name-feature-description`
- `fix/package-name-issue-description`
- `docs/description`

### Commit Messages

Follow conventional commits format:

```txt
type(scope): description

[optional body]

[optional footer]
```

Types: `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`

## Maintenance and Evolution

### Dependency Management

- Minimize external dependencies
- Prefer standard library over external packages
- Pin dependency versions in go.mod
- Regular security updates

### Backwards Compatibility

- Use semantic versioning
- Deprecate before removing functionality
- Provide migration paths for breaking changes
- Document all breaking changes clearly

### Continuous Improvement

- Regular code quality reviews
- Update standards based on lessons learned
- Incorporate Go community best practices
- Maintain living documentation

## AI Assistant Specific Instructions

When working on this project:

1. **Always check existing patterns** before implementing new functionality
2. **Follow established conventions** rather than introducing new ones
3. **Test thoroughly** - include unit tests, integration tests, and examples
4. **Document comprehensively** - update all relevant documentation
5. **Validate quality** - ensure all quality gates pass
6. **Ask for clarification** if project patterns are unclear
7. **Suggest improvements** when you see opportunities for better practices

Remember: These guidelines exist to maintain consistency and quality. When in doubt, follow the existing patterns in the codebase and ask for guidance on new approaches.

## Project Context and History

### Recent Major Changes

- **Granular Hot Reload**: Config package now supports independent schema and config file watching
- **Environment Variables**: Added support for `$VAR`, `${VAR}`, and `${VAR:-default}` patterns
- **Inline Schemas**: Config package supports embedding CUE schemas directly in code
- **Component Logging**: Enhanced logging with component-aware loggers and context integration
- **Documentation Standardization**: All package docs follow consistent template structure
- **Dead Code Removal**: Cleaned up unused functions and maintained only essential APIs

### Architecture Decisions

- **CUE Integration**: Heavy use of CUE for schema validation and expression evaluation
- **Standard Library First**: Prefer Go standard library over external dependencies
- **Interface-Based Design**: Return interfaces from constructors for flexibility
- **Context-Aware**: All long-running operations support context for cancellation
- **Thread-Safe by Design**: All public APIs are safe for concurrent use

### Performance Characteristics

- **Config**: Sub-microsecond access after initial parsing and caching
- **Logging**: Minimal overhead structured logging with efficient field handling
- **Ruler**: ~8μs rule evaluation with smart pre-filtering and compilation

## Common Anti-Patterns to Avoid

### Code Anti-Patterns

- **Ignoring Errors**: Never use `_` to ignore errors
- **Global State**: Avoid global variables, use dependency injection
- **Large Functions**: Keep functions under 50 lines, prefer composition
- **Deep Nesting**: Use early returns to reduce nesting levels
- **Magic Numbers**: Use named constants for all numeric values

### Documentation Anti-Patterns

- **Marketing Language**: Avoid "production-grade", "enterprise-level", "world-class"
- **Outdated Examples**: Ensure all code examples match current API
- **Missing Context**: Always explain why, not just what
- **Inconsistent Formatting**: Follow the established template structure
- **Broken Links**: Verify all links work before committing

### Testing Anti-Patterns

- **Testing Implementation**: Test behavior, not internal implementation details
- **Shared State**: Each test should be independent and isolated
- **Complex Setup**: Use helper functions to simplify test setup
- **Missing Edge Cases**: Test both happy path and error conditions
- **Slow Tests**: Keep tests fast, use mocking for external dependencies

## Integration Guidelines

### Working with Existing Code

- **Study Patterns**: Examine existing code before making changes
- **Maintain Consistency**: Follow established patterns rather than introducing new ones
- **Incremental Changes**: Make small, focused changes rather than large refactors
- **Preserve Behavior**: Don't change existing behavior unless explicitly required
- **Update Tests**: Ensure tests reflect any behavioral changes

### Adding New Features

- **Design First**: Consider the API design and how it fits with existing patterns
- **Interface Design**: Define interfaces before implementing concrete types
- **Error Handling**: Design error types and handling patterns early
- **Documentation**: Write documentation alongside code, not after
- **Testing Strategy**: Plan test coverage including edge cases and error conditions

### Refactoring Guidelines

- **Small Steps**: Make incremental improvements rather than large rewrites
- **Preserve Tests**: Keep existing tests passing during refactoring
- **Maintain API**: Avoid breaking changes unless absolutely necessary
- **Document Changes**: Update documentation to reflect any changes
- **Performance Impact**: Measure performance impact of refactoring changes

## Debugging and Troubleshooting

### Common Issues

- **Import Cycles**: Use interfaces and dependency injection to break cycles
- **Race Conditions**: Use `go test -race` to detect and fix race conditions
- **Memory Leaks**: Ensure proper cleanup of goroutines and resources
- **Performance Issues**: Use benchmarks and profiling to identify bottlenecks
- **Configuration Errors**: Validate configuration early and provide clear error messages

### Debugging Tools

- **Delve**: Go debugger for step-through debugging
- **pprof**: Built-in profiling for CPU and memory analysis
- **Race Detector**: Built-in race condition detection
- **Benchmarks**: Performance measurement and regression detection
- **Logging**: Strategic logging for debugging complex issues

## Security Considerations

### Input Validation

- **Validate Early**: Validate all external inputs at package boundaries
- **Sanitize Data**: Clean and validate data before processing
- **Limit Resources**: Implement appropriate limits on resource usage
- **Error Messages**: Don't leak sensitive information in error messages
- **File Operations**: Use safe file operations with proper permissions

### Dependency Security

- **Regular Updates**: Keep dependencies updated for security fixes
- **Vulnerability Scanning**: Use gosec and other tools for security scanning
- **License Compliance**: Ensure all dependencies have compatible licenses
- **Minimal Dependencies**: Only add dependencies that provide significant value
- **Audit Trail**: Document reasons for adding new dependencies

## Release and Deployment

### Version Management

- **Semantic Versioning**: Use semver for all releases (MAJOR.MINOR.PATCH)
- **Breaking Changes**: Only in major version releases
- **Feature Additions**: Minor version releases
- **Bug Fixes**: Patch version releases
- **Clear Changelog**: Document all changes in release notes

### Release Process

- **Quality Gates**: All automated checks must pass
- **Documentation**: Ensure docs are current and accurate
- **Testing**: Full test suite including integration tests
- **Security Scan**: No high-severity security issues
- **Performance**: No significant performance regressions
- **Backwards Compatibility**: Maintain compatibility within major versions

This comprehensive guide should be referenced for all development work on the Geekxflood Common project. It represents the collective knowledge and standards developed through the project's evolution and should be treated as the authoritative source for development practices.
